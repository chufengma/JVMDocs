从接触到Java的第一天开始，教材就告诉我们，使用Java不需要关心new出来的对象所占用的内存什么时候释放，因为Java有一个牛逼的机制：垃圾回收（GC）。它懂得在什么时候如何释放内存，一切都是自动的，对程序员透明的。那么垃圾回收机制究竟是如何工作的呢：它怎么判断对象已经可以被回收？它如何回收对象？应该什么时候回收？

#### 哪些对象可以被回收

通过引用计数算法和可行性分析算，可以决定哪些对象可以被回收：

引用计数算法  当有引用指向该对象的时候对象的引用计数就+1，引用置空的时候-1，当引用计数为0的时候，就表示对象可以被回收了。显然的，引用计数方式在实现上看起来很简单并且很高效，但是很难解决循环引用的问题，比如a对象有个域是b，b对象有个域是a，此时引用计数永不为0。（其它语言通过判断在合适的时候断开a,b之间的循环或者通过弱引用的方式来解决这个问题）但目前没有Java虚拟机采用这种方式。

可行性分析算法(Reachability Analysis)  定义一组Root对象，从任意Root对象到目标对象之间引用关系不可达的话，则该对象可以回收。这种方式不用关心引用之间的依赖关系，只要沿着引用链达到不了任意Root对象的话就可以回收。Jvm 定义Root对象包括： **虚拟机栈中的对象，方法区中静态属性引用的对象，方法区中常量引用的对象，native方法栈中引用的对象**。目前主流虚拟机都是采用可行性分析算法标记待回收的对象。

#### 引用的类型

- 强引用 默认情况下大部分引用都是强引用，比如new出来或者反射构造出来的。任何时候虚拟机都不会回收该对象。
- 软引用 SoftReference，当系统内存不足（OOM）的时候，将回收软引用引用的对象，如果回收之后内存还是不够，则会抛出OOM
- 弱引用 WeakReference, 每次系统进行GC的时候, 都会回收。
- 虚引用 PhantomReference，这种引用关系仅仅用来当系统将要回收该对象的时候获取一个通知。不引用引用的对象任何回收的逻辑。

#### 如何回收对象

下面四种算法顺序渐进来说明JVM中如何回收对象：

标记-清除算法 包括俩个过程，先标记，让所有要回收的对象写入回收标记，然后清除。这个算法最基本，但是也有比较大的问题：1.效率不高 2. 内存碎片太多，当后续有大对象要分配的时候，找不到连续的内存空间。
![标记清除](https://raw.githubusercontent.com/chufengma/JVMDocs/master/images/jvm_gc_mark_clean.png)

复制算法 将内存分为大小相等的俩块，在执行垃圾回收的时候，扫面一块区域，如果某个对象不需要回收则将该对象复制到另一内存块中，扫描完成剩下的对象一次性清除。这个算法效率较高，但内存利用率太差。可以优化这种算法，如果一块内存区域大部分对象都是需要回收的，那么不需要按照1：1比例分配内存从而达到优化，这种优化后的算法适合有大量需要回收的对象的区域，即新生代。
![标记清除](https://raw.githubusercontent.com/chufengma/JVMDocs/master/images/jvm_gc_copy.png)

标记-整理算法 先标记要回收的对象，然后将存活的对象向一端移动，完成后清除所有边界的对象。这样可以避免标记-清除算法中的大量内存碎片。这种方式比较适合只有小部分对象要回收的区域，即老年代。
![标记清除](https://raw.githubusercontent.com/chufengma/JVMDocs/master/images/jvm_gc_mark_zhengli.png)

分代收集算法 结合负责算法和标记整理算法，完全可以对不同内存区域执行不同方法。即新生代使用复制算法，老年代使用标记-清除或标记-整理算法。这也是目前JVM使用的垃圾回收算法。

#### 新生代和老年代

为了对不同生命周期和大小的对象使用不同的垃圾回收算法，JVM将堆内存分为新生代和老年代。
