从接触到Java的第一天开始，教材就告诉我们，使用Java不需要关心new出来的对象所占用的内存什么时候释放，因为Java有一个牛逼的机制：垃圾回收（GC）。它懂得在什么时候如何释放内存，一切都是自动的，对程序员透明的。那么垃圾回收机制究竟是如何工作的呢：它怎么判断对象已经可以被回收？它如何回收对象？回收策略是什么样的？

#### 哪些对象可以被回收

通过引用计数算法和可行性分析算，可以决定哪些对象可以被回收：

引用计数算法  当有引用指向该对象的时候对象的引用计数就+1，引用置空的时候-1，当引用计数为0的时候，就表示对象可以被回收了。显然的，引用计数方式在实现上看起来很简单并且很高效，但是很难解决循环引用的问题，比如a对象有个域是b，b对象有个域是a，此时引用计数永不为0。（其它语言通过判断在合适的时候断开a,b之间的循环或者通过弱引用的方式来解决这个问题）但目前没有Java虚拟机采用这种方式。

可行性分析算法(Reachability Analysis)  定义一组Root对象，从任意Root对象到目标对象之间引用关系不可达的话，则该对象可以回收。这种方式不用关心引用之间的依赖关系，只要沿着引用链达到不了任意Root对象的话就可以回收。Jvm 定义Root对象包括： **虚拟机栈中的对象，方法区中静态属性引用的对象，方法区中常量引用的对象，native方法栈中引用的对象**。目前主流虚拟机都是采用可行性分析算法标记待回收的对象。

#### 引用的类型

- 强引用 默认情况下大部分引用都是强引用，比如new出来或者反射构造出来的。任何时候虚拟机都不会回收该对象。
- 软引用 SoftReference，当系统内存不足（OOM）的时候，将回收软引用引用的对象，如果回收之后内存还是不够，则会抛出OOM
- 弱引用 WeakReference, 每次系统进行GC的时候, 都会回收。
- 虚引用 PhantomReference，这种引用关系仅仅用来当系统将要回收该对象的时候获取一个通知。不引用引用的对象任何回收的逻辑。

#### 如何回收对象

下面四种算法顺序渐进来说明JVM中如何回收对象：

标记-清除算法 包括俩个过程，先标记，让所有要回收的对象写入回收标记，然后清除。这个算法最基本，但是也有比较大的问题：1.效率不高 2. 内存碎片太多，当后续有大对象要分配的时候，找不到连续的内存空间。

![标记清除](https://raw.githubusercontent.com/chufengma/JVMDocs/master/images/jvm_gc_mark_clean.png)

复制算法 将内存分为大小相等的俩块，在执行垃圾回收的时候，扫面一块区域，如果某个对象不需要回收则将该对象复制到另一内存块中，扫描完成剩下的对象一次性清除。这个算法效率较高，但内存利用率太差。可以优化这种算法，如果一块内存区域大部分对象都是需要回收的，那么不需要按照1：1比例分配内存从而达到优化，这种优化后的算法适合有大量需要回收的对象的区域，即新生代。

![标记清除](https://raw.githubusercontent.com/chufengma/JVMDocs/master/images/jvm_gc_copy.png)

标记-整理算法 先标记要回收的对象，然后将存活的对象向一端移动，完成后清除所有边界的对象。这样可以避免标记-清除算法中的大量内存碎片。这种方式比较适合只有小部分对象要回收的区域，即老年代。

![标记清除](https://raw.githubusercontent.com/chufengma/JVMDocs/master/images/jvm_gc_mark_zhengli.png)

分代收集算法 结合负责算法和标记整理算法，完全可以对不同内存区域执行不同方法。即新生代使用复制算法，老年代使用标记-清除或标记-整理算法。这也是目前JVM使用的垃圾回收算法。

#### 新生代和老年代

为了对不同生命周期和大小的对象使用不同的垃圾回收算法，JVM将堆内存分为新生代和老年代。

新生代又称为Eden区域，JVM优先将对象分配在新生代，由于JVM中大部分对象是朝生夕灭的，所以适合使用复制算法来进行垃圾回收，那些回收保存下来的对象将复制到幸存区。对新生代垃圾回收被称为MinorGC, MinorGC回收快效率高，通常比较频繁。

新生代对象有一个年龄计数，每次GC存活下来的对象计数将+1，当新生代对象计数超过虚拟机设置最大值时候（默认是15），对象将放入老年代。

老年代对象经过新生代残酷的GC过程存活下来，通常不太容易回收，因此适合使用标记整理算法，对老年代对象的回收称为 MajorGC或FullGC, 大部分时候触发MajorGC也会触发MinorGC, MajorGC过程较慢比MinorGC慢10倍以上。

除了新生代『长大』的对象，大对象也会直接分配到老年区，比如大字符串，或者大数组。由于老年区垃圾回收比较慢，因此编程过程要尽量少定义一些大的短暂使用的对象。

#### 回收需要考虑的一些问题

当内存不足时候，将触发垃圾回收。可行性分析算法需要从根节点扫面对象，此时需要暂停所有JVM工作线程，直至回收结束。此时运行的程序必然会停顿。HotSpot JVM为了加快根节点枚举速度，使用OopMap数据结构，它在运行时记录的对象的操作，垃圾回收的时候直接读取，快速枚举。

在需要垃圾回收的时候， 并不是任意时刻都能立刻停下来，比如正在进行引用分配等等。HotSpot在运行时标记了很多安全点和安全区域，在安全点执行GC才是安全的（比如方法调用，循环跳转等等地方）
