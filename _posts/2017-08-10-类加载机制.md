我们的Java文件被javac编译之后变成字节码文件，这个文件是怎么被虚拟机加载并变成方法区的类的呢？加载的时机是什么样的？我们能控制加载的过程吗？



#### 加载类的时机

一个jar文件或者多个jar文件在运行的时候，这些类什么时候加载呢？是一次性全部加载进去还是用到的时候加载？父类和子类加载顺序是什么样的？

虚拟机规定如下情况下 需要初始类类实例：

- 虚拟器启动的时候，要执行的主类需要先初始化


- 使用new 实例化对象，读取、设置一个类的静态字段（final x修饰放入常量池的静态字段除外），调用类的静态方法。
  
- 使用java.lang.reflect放对类进行反射的时候
  
- 初始化类如果父类没有初始化，则需要初始化父类
  
- 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。
  
  

#### 加载类的过程

虚拟机中Java类的生命周末周期：加载、验证、准备、解析、初始化、使用、卸载。其中『加载』过程如下：

- 加载，根据类的全限定名来获取类的二进制字节流，把字节流转换成方法区的数据结构，并在堆内存中生成一个代表这个类的java.lang.Class实例。
  
  这里的类文件不光是文件，还包括网络流，什么运行时计算出来的类
  
- 验证，验证是否符合Class文件格式规范，验证类基本信息，验证字节码合法性。
  
- 准备，在方法区给类变量分配内存
  
- 解析，解析类结构和数据流
  
- 初始化，实例化类实例
  
  

#### 类加载器

Java对外暴露了类加载器，让程序员可以控制类的加载。确定一个类的唯一性是：类路径和类加载器。

类加载器划分类三大类，启动类加载器（Bootstrap ClassLoader），这部分由C++实现，用来加载系统核心类，(rt.jar …)。扩展类加载器（Extension ClassLoader）负责ext目录下的类。应用程序加载器（Application ClassLoader）,这个加载器可以通过System.getSystemClassLoader()。

我们的类是通过这三种类配合加载的，一般使用 双亲委托模型进行加载：

类先由父类加载器加载，如果父类加载失败再依次交由下一层加载器加载，依次类推。这样做的有利于Java库的稳定性，越底层的类越交由底层类加载器加载。

这种加载模型只是一种约定，程序员完全可以自己实现加载机制。

类加载器机制可以实现很多牛叉的功能，例如热修复，模块化加载，包括android中的插件化都是基于类加载机制。

