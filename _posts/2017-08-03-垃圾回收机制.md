从接触到Java的第一天开始，教材就告诉我们，使用Java不需要关心new出来的对象所占用的内存什么时候释放，因为Java有一个牛逼的机制：垃圾回收（GC）。它懂得在什么时候如何释放内存，一切都是自动的，对程序员透明的。那么垃圾回收机制究竟是如何工作的呢：它怎么判断对象已经可以被回收？应该什么时候回收？它如何回收对象？

#### 哪些对象可以被回收

- 引用计数算法  当有引用指向该对象的时候对象的引用计数就+1，引用置空的时候-1，当引用计数为0的时候，就表示对象可以被回收了。显然的，引用计数方式在实现上看起来很简单并且很高效，但是很难解决循环引用的问题，比如a对象有个域是b，b对象有个域是a，此时引用计数永不为0。（其它语言通过判断在合适的时候断开a,b之间的循环或者通过弱引用的方式来解决这个问题）但目前没有Java虚拟机采用这种方式。

- 可行性分析算法(Reachability Analysis)  定义一组Root对象，从任意Root对象到目标对象之间引用关系不可达的话，则该对象可以回收。这种方式不用关心引用之间的依赖关系，只要沿着引用链达到不了任意Root对象的话就可以回收。Jvm 定义Root对象包括： **虚拟机栈中的对象，方法区中静态属性引用的对象，方法区中常量引用的对象，native方法栈中引用的对象**。目前主流虚拟机都是采用可行性分析算法标记待回收的对象。

#### 引用的类型

- 强引用 默认情况下大部分引用都是强引用，比如new出来或者反射构造出来的。任何时候虚拟机都不会回收该对象。
- 软引用 SoftReference，当系统内存不足（OOM）的时候，将回收软引用引用的对象，如果回收之后内存还是不够，则会抛出OOM
- 弱引用 WeakReference, 每次系统进行GC的时候, 都会回收。
- 虚引用 PhantomReference，这种引用关系仅仅用来当系统将要回收该对象的时候获取一个通知。不引用引用的对象任何回收的逻辑。

#### 
