
### 内存区域划分 

当一个JVM进程被启动起来之后，便划分好了几块内存区域：方法区，堆区，虚拟机栈区，native方法栈区，和程序计数器区。我们来逐一说明每个区存放的具体内容和发挥的作用。

_**堆区**_  是虚拟机管理的最大的一块内存区域，也是垃圾回收的主要区域。堆区只存放对象实例，几乎所有的对象实例都在此被分配（包括对象和数组）。这个区域没用足够内存则会抛出OOM

_**方法区**_  用来存储被虚拟机加载的类信息，静态变量，运行时常量池（包括字符串常量池，但后续虚拟机可能会放到 native内存中存放）等信息。这个区域没用足够内存则会抛出OOM

_**程序计数器**_   是当前虚拟机执行的行号指示器，各种逻辑指令都依赖计数器来执行，循环，跳转，异常输出，线程恢复等。需要注意的是，程序计数器一般占用内存很小，虚拟机也没用对此规定任何OOM的异常情况。

_**native方法栈区**_  是虚拟机执行native方法需要的方法栈内存空间存放区域，这个区域比较自由，但允许出现OOM和SOF异常。

_**虚拟机栈区**_  是执行java方法需要的栈空间内存存放区域。jvm中，每个方法的执行都会创建一个栈帧（stack frame）用于存储局部变量表，方法出入口等信息，每一次调用方法对应就是栈帧入栈和出栈的过程。局部变量表存放的就是运行时已知的一些数据类型：byte,int,long...和reference类型。当线程请求的栈深度大于可用深度的时候会抛出SOF异常，当没用足够内存使用则抛出OOM。

其中 方法去和堆区是所有线程共享的，但虚拟机栈区，native方法区和程序计数器都是和具体线程相关，图示如下：

 ![虚拟机内存分布](https://raw.githubusercontent.com/chufengma/JVMDocs/master/images/jvm_reading_note_mem_brief.png)

_虚线表示线程各自拥有_

### 对象的创建和访问

当我们在一个方法中，通过new创建一个对象的时候虚拟机究竟是怎么分配内存的呢：

- 引入类：首先会判断当前类是否被虚拟机引入，如果没有引入则在方法区分配内存存放类信息。
- 创建对象：对象的创建在堆上，这地方有俩种分配访问策略，一种是通过句柄池来访问，另一部分是直接指针。句柄池是java虚拟机会在堆上分配一块内存用作句柄池，句柄存放俩部分数据，一部分是堆上创建对象的实例数据地址，另一部分指向的是方法区引入的类信息地址。而直接指针则直接分配一块内存包括实例数据和指向类信息地址的指针。具体哪种方式由虚拟机实现。
- 入栈：在java栈本地变量表创建引用，引用指向句柄的地址或者直接指向对象地址。

句柄池方式图示如下：

![虚拟机内存分布](https://raw.githubusercontent.com/chufengma/JVMDocs/master/images/jvm_reading_not_create_ref.png)






